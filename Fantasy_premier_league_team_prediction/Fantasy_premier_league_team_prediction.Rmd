---
# IMPORTANT: Change settings here, but DO NOT change the spacing.
# Remove comments and add values where applicable.
# The descriptions below should be self-explanatory

title: "Predicting the best fantasy premier league team to pick per gameweek"
#subtitle: "This will appear as Right Header"

documentclass: "elsarticle"

# --------- Thesis title (Optional - set to FALSE by default).
# You can move the details below around as you please.
Thesis_FP: FALSE
# Entry1: "An unbelievable study with a title spanning multiple lines."
# Entry2: "\\textbf{Some Guy}" # textbf for bold
# Entry3: "A thesis submitted toward the degree of Doctor of Philosophy"
# Uni_Logo: Tex/Logo.png # Place a logo in the indicated location (from your root, e.g. defaults to ~/Tex/Logo.png) and uncomment this line. Leave uncommented for no image
# Logo_width: 0.3 # If using a logo - use this to set width (size) of image
# Entry4: "Under the supervision of: \\vfill Prof. Joe Smith and Dr. Frank Smith"
# Entry5: "Stellenbosch University"
# Entry6: April 2020
# Entry7:
# Entry8:

# --------- Front Page
# Comment: ----- Follow this pattern for up to 5 authors
AddTitle: TRUE # Use FALSE when submitting to peer reviewed platform. This will remove author names.
Author1: "Austin Byrne"  # First Author - note the thanks message displayed as an italic footnote of first page.
Ref1: "Stellenbosch University, South Africa" # First Author's Affiliation
Email1: "22582053\\@sun.ac.za" # First Author's Email address

#Author2: "John Smith"
#Ref2: "Some other Institution, Cape Town, South Africa"
#Email2: "John\\@gmail.com"
#CommonAffiliation_12: TRUE # If Author 1 and 2 have a common affiliation. Works with _13, _23, etc.

#Author3: "John Doe"
#Email3: "Joe\\@gmail.com"

#CorrespAuthor_1: TRUE  # If corresponding author is author 3, e.g., use CorrespAuthor_3: TRUE

# Comment out below to remove both. JEL Codes only given if keywords also given.
#keywords: "Multivariate GARCH \\sep Kalman Filter \\sep Copula" # Use \\sep to separate
#JELCodes: "L250 \\sep L100"

# ----- Manage headers and footers:
#BottomLFooter: $Title$
#BottomCFooter:
#TopLHeader: \leftmark # Adds section name at topleft. Remove comment to add it.
BottomRFooter: "\\footnotesize Page \\thepage" # Add a '#' before this line to remove footer.
#addtoprule: TRUE
#ddfootrule: TRUE               # Use if footers added. Add '#' to remove line.

# --------- page margins:
margin: 2.3 # Sides
bottom: 2 # bottom
top: 2.5 # Top
HardSet_layout: TRUE # Hard-set the spacing of words in your document. This will stop LaTeX squashing text to fit on pages, e.g.
# This is done by hard-setting the spacing dimensions. Set to FALSE if you want LaTeX to optimize this for your paper.

# --------- Line numbers
linenumbers: FALSE # Used when submitting to journal

# ---------- References settings:
# You can download cls format here: https://www.zotero.org/ - simply search for your institution. You can also edit and save cls formats here: https://editor.citationstyles.org/about/
# Hit download, store it in Tex/ folder, and change reference below - easy.
bibliography: Tex/ref.bib       # Do not edit: Keep this naming convention and location.
csl: Tex/harvard-stellenbosch-university.csl # referencing format used.
# By default, the bibliography only displays the cited references. If you want to change this, you can comment out one of the following:
#nocite: '@*' # Add all items in bibliography, whether cited or not
# nocite: |  # add specific references that aren't cited
#  @grinold2000
#  @Someoneelse2010

# ---------- General:
RemovePreprintSubmittedTo: TRUE  # Removes the 'preprint submitted to...' at bottom of titlepage
#Journal: "Journal of Finance"   # Journal that the paper will be submitting to, if RemovePreprintSubmittedTo is set to TRUE.
toc: FALSE                       # Add a table of contents
numbersections: TRUE             # Should sections (and thus figures and tables) be numbered?
fontsize: 11pt                  # Set fontsize
linestretch: 1.2                # Set distance between lines.
link-citations: TRUE            # This creates dynamic links to the papers in reference list.

### Adding additional latex packages:
# header-includes:
#    - \usepackage{colortbl} # Add additional packages here.

output:
  pdf_document:
    keep_tex: TRUE
    template: Tex/TexDefault.txt
    fig_width: 3.5 # Adjust default figure sizes. This can also be done in the chunks of the text.
    fig_height: 3.5
abstract: |
  Abstract to be written here. The abstract should not be too long and should provide the reader with a good understanding what you are writing about. Academic papers are not like novels where you keep the reader in suspense. To be effective in getting others to read your paper, be as open and concise about your findings here as possible. Ideally, upon reading your abstract, the reader should feel he / she must read your paper in entirety.
---

<!-- First: Set your default preferences for chunk options: -->

<!-- If you want a chunk's code to be printed, set echo = TRUE. message = FALSE stops R printing ugly package loading details in your final paper too. I also suggest setting warning = FALSE and checking for warnings in R, else you might find ugly warnings in your paper. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 5, fig.pos="H", fig.pos = 'H')
# Note: Include = FALSE implies the code is executed, but not printed in your pdf.
# warning and message = FALSE implies ugly messages and warnings are removed from your pdf.
# These should be picked up when you execute the command chunks (code sections below) in your rmd, not printed in your paper!

# Lets load in example data, and see how this can be stored and later called from your 'data' folder.
if (!require("pacman")) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, rpart, caret, rpart.plot, 
               vip, pdp, doParallel, foreach, tidyr,  
               ipred, ranger, gbm, xgboost, AmesHousing, ggrepel, tidyverse, Metrics)

list.files('C:/Users/austi/OneDrive/Desktop/Masters/Data Science/22582053_ML_project/Fantasy_premier_league_team_prediction/code', full.names = T, recursive = T) %>% as.list() %>% walk(~source(.))

```


<!-- ############################## -->
<!-- # Start Writing here: -->
<!-- ############################## -->

# Introduction \label{Introduction}


# Data exploration

```{r include=FALSE}
# Loading the data into R
library(readr)
merged_gameweek_2021_22 <- read_csv("C:/Users/austi/OneDrive/Desktop/Masters/Data Science/22582053_ML_project/data/merged gameweek 2021-22.csv")

merged_gameweek_2022_23 <- read_csv("C:/Users/austi/OneDrive/Desktop/Masters/Data Science/22582053_ML_project/data/merged gameweek 2022-23.csv")
```

## Correlation plot between player attributes and total points

```{r warning =  FALSE, fig.align = 'center', fig.cap = "Player attributes correlation plot\\label{Figure1}", fig.ext = 'png', fig.height = 6, fig.width = 6}
player_correlation_plot <- create_player_correlation_plot(merged_gameweek_2021_22)

player_correlation_plot
```

The above \ref{Figure1} represents a correlation plot of player attributes for the purpose of identifying which player attributes have the biggest impact on total points earned by players. This is valuable information as we can then add these most prominent variables into our random forests model in an attempt to obtain accurate prediction results. 

From \ref{Figure1} it is evident that a players influence score, ict_index, threat, selected, transfers in and creativity scores are positively correlated to the total points variable, which is the variable we are trying to predict. Thus, when building our random forests model these variables must be added. Furthermore, we must now look at the correlation between total points and team attributes. 

## Correlation plot between team attributes and individual player points

```{r warning =  FALSE, fig.align = 'center', fig.cap = "Team attributes correlation plot\\label{Figure2}", fig.ext = 'png', fig.height = 6, fig.width = 6}
team_correlation_plot <- create_team_correlation_plot(merged_gameweek_2021_22)

team_correlation_plot
```

\ref{Figure2} represents the correlation plot for team attributes such as whether the team is playing at home that game week, the team they are playing against and which game week it is for that specific match.As can be seen from \ref{Figure2} the team attributes actually don't have much of a correlation with the total points scored by players other than the slight correlation between the round and fixture with total points. However, this correlation seems so small that it will irrelevant to add into our model.  



## Plotting the average points scored per position per gameweek: 

```{r warning =  FALSE, fig.align = 'center', fig.cap = "Average points per position combined plot\\label{Figure3}", fig.ext = 'png', fig.height = 6, fig.width = 6}

average_points_per_position_combined_plot <- create_average_points_per_position_plot(merged_gameweek_2021_22)

average_points_per_position_combined_plot
```

The above figure \ref{Figure3} provides some very valuable information on how many points are scored per position per game week throughout the 2021/22 premier league season. Each point on the above graph represents the average points scored for a position (either DEF which represents defenders, FWD which represents forwards, GK which represents goal keepers, or MID witch represents midfielders) for that particular game week. Some important takeaways can be found in this graph. 

Goalkeepers on average seem to score the lowest points per game week, while strikers and defenders seem to have the highest variation and unpredictability. Midfielders seem to have on average the highest average points throughout the entire 2021/22 premier league season. In order to obtain i clearly picture of the distribution of points per postion the following figure will split the positions into their own respective plots. 

## Now plotting the average points per postion on differetn axis and plotting the overall average points scored per postion. 

```{r warning =  FALSE, fig.align = 'center', fig.cap = "Average points per postion individual plots\\label{Figure4}", fig.ext = 'png', fig.height = 6, fig.width = 6}

average_points_position_2021_22 <- aggregate(total_points ~ GW + position, data = merged_gameweek_2021_22, FUN = mean)

average_points_per_position_plot <- create_average_points_with_horizontal_lines_plot(average_points_position_2021_22)

average_points_per_position_plot

```

\ref{Figure4} provides a clearer picture of the distribution and confirms the takeaways made in response to \ref{Figure3}. \ref{Figure4} places each positions average point distribution throughout the 2021/22 season onto their own plot and places a horizontal line on the plot that represents the overall average for that position. It can be confirmed that goal keepers do in fact score on average the lowest points per game week, defenders and strikers have a higher variation and midfielders seem to be the best bet to obtain a better chance of receiving higher points throughout the season. 

The takeaway that can me made from the evidence of \ref{Figure3} and \ref{Figure4} is that you will want to have as many midfielders in your team as possible to take advantage of their higher average points and lower variance. 

Although some good analysis has been done on which attributes impact individual players total points the most and which positions score the most points, we have not yet taken into account how expensive these players are in these positions. This is a very important variable to evaluate due to the 100 mil cap on your fantasy team. This analysis will be conducted next. 


## Scatter plot for points per value: 

```{r warning =  FALSE, fig.align = 'center', fig.cap = "Scatter plot of players points per value\\label{Figure5}", fig.ext = 'png', fig.height = 6, fig.width = 6}
most_valueable_players <- create_scatter_plot_with_top_players(merged_gameweek_2021_22, 3)

most_valueable_players
```

The above scatter plot \ref{Figure5} provides us with some more valuable insight. On the y axis we have the average total points per player and on the x axis we have the players value. Each point on this scatter plot provides us with the points per value statistic. In you you fantasy premier league team you will want players with high points per value ratios. In the plot it is visible that defenders are much cheaper than midfielders and forwards. Thus, getting some good cheap defenders in your team may be beneficial. Furthermore, this plot prints the names of the three players with the highest points per value ratios. These players are namely, Reece james (defender), Jack Harrison (midfielder) and Matt Doherty (defender). It is important to find players that are booth cheap and provide good points to your fantasy team. 

Finally, lets evaluate if having a certain premier league team dominate your fantasy team is a viable option. This analysis will be done in the following figure. 


## Min/mean and max points per team for a gameweek: 

```{r warning =  FALSE, fig.align = 'center', fig.cap = "Team points min average and max distribution plot\\label{Figure6}", fig.ext = 'png', fig.height = 6, fig.width = 6}
team_points_distribution_plot <- create_team_points_distribution_plot(merged_gameweek_2021_22)

team_points_distribution_plot
```

\ref{Figure6} provides insight into the minimum, average and maximum points scored per team in the premier league. From this figure it can be seen that you would rather want to avoid having players from Watford, Norwich and Everton due to their low average points and low maximum points. The teams that you should look to have players from are Man city, Liverpool and Chelsea. These team posses the highest average points and highest total points. Although the fantasy premier league restriction of a maximum of three players per team are allowed makes this difficult. This restriction ensures that we cannot flood our fantasy team with just Man city players or just Liverpool players. 

## Conclusions made from data analysis 

The important notes made form this data analysis is that, creativity, ict_index, influence, threat, selected and transfers in are important variables to place in the random forests model as they have explanatory power. Furthermore, when choosing your formation of your fantasy premier league team you should look to have as many midfielders as possible and look to obtain players from Man city, Liverpool or Chelsea. 

# Machine learning model using Random forests

## Setup process of machine learning model

```{r include=FALSE}
# Getting the value variable in my dataset into the correct fromat
merged_gameweek_2021_22$value <- merged_gameweek_2021_22$value / 10

merged_gameweek_2022_23$value <- merged_gameweek_2022_23$value / 10

# Creating  a new data set that only contains variables that can be seen before the game starts
predicter_variables_2021_22 <- c("creativity", "ict_index", "influence", "selected", "threat", "transfers_in", "total_points")

# Subset the data frame to keep only the selected variables
adapted_merged_gameweek_2021_22 <- merged_gameweek_2021_22[, predicter_variables_2021_22]

```

### Creating the base random forests model

```{r}
# The baseline model
# Splittting the data into train and test sets

library(rsample)
set.seed(123)
split <- rsample::initial_split(adapted_merged_gameweek_2021_22, prop = 0.7, 
                       strata = "total_points")
twenty21_train  <- training(split)
twenty21_test   <- testing(split)
```

```{r}
set.seed(123)

ctrl <- trainControl(method="repeatedcv", 
                     number=5, 
                     repeats = 3)

# number of features
n_features <- length(setdiff(names(twenty21_train), "total_points"))
```

```{r}
# Now we start the modeling

fpl_2021_22_forest <- train(total_points~., twenty21_train, method="rf", trControl= ctrl, ntree = 50)


fpl_2021_22_prediction_test <- predict(fpl_2021_22_forest, twenty21_test)
fpl_2021_22_prediction_train <- predict(fpl_2021_22_forest, twenty21_train)
```

### Evaluating the performance of the base line model

```{r}
yardstick::mae_vec(truth = twenty21_train$total_points, estimate = fpl_2021_22_prediction_train)

yardstick::mae_vec(truth =  twenty21_test$total_points, estimate = fpl_2021_22_prediction_test)
```


## Hyper parameter tuning 

### mtry hyper parameter tuning

```{r}
library(caret)


# Create train control object for repeated cross-validation
ctrl <- trainControl(method = "repeatedcv",
                     number = 5,
                     repeats = 3)

# Define the tuning grid for mtry
tuning_grid <- expand.grid(mtry = c(1, 2, 3, 4, 5))

# Perform hyperparameter tuning using the train function
fpl_2021_22_tuned <- train(total_points ~ .,
                           data = twenty21_train,
                           method = "rf",
                           trControl = ctrl,
                           tuneGrid = tuning_grid,
                           ntree = 50)

# Obtain the optimal mtry value
optimal_mtry <- fpl_2021_22_tuned$bestTune$mtry

# Train the random forest model with the optimal mtry value
final_model <- randomForest::randomForest(total_points ~ .,
                                          data = twenty21_train,
                                          mtry = optimal_mtry,
                                          ntree = 50)

# Make predictions on the test set
fpl_2021_22_prediction_test <- predict(final_model, twenty21_test)

# Load the required library
library(Metrics)

# Calculate mean absolute error (MAE)
mae <- mae(twenty21_test$total_points, fpl_2021_22_prediction_test)

# Shows that mtry = 2 is the best
```

### k-fold Hyper parameter tuning

```{r}
library(caret)

# Define the range of folds to test
fold_range <- c(5, 10, 15, 20)

# Initialize vectors to store results
mae_values <- numeric(length(fold_range))

# Iterate over each fold value
for (i in 1:length(fold_range)) {
  # Create train control object with the current fold value
  ctrl <- trainControl(method = "cv",
                       number = fold_range[i])
  
  # Train the model and perform cross-validation
  model <- train(total_points ~ .,
                 data = twenty21_train,
                 method = "rf",
                 trControl = ctrl,
                 tuneLength = 1)
  
  # Make predictions on the test set
  predictions <- predict(model, twenty21_test)
  
  # Calculate mean absolute error (MAE)
  mae_values[i] <- mean(abs(twenty21_test$total_points - predictions))
}

# Find the fold value with the lowest MAE
optimal_fold <- fold_range[which.min(mae_values)]


# Shows that k = 5 is the best 
```

# ntree hyper parameter tuning 

```{r}
# Create train control object for repeated cross-validation
ctrl <- trainControl(method = "repeatedcv",
                     number = 5,
                     repeats = 3)

# Define the tuning grid for mtry
tuning_grid <- expand.grid(mtry = c(1, 2, 3, 4, 5))

# Initialize variables to store the best performance
best_mae <- Inf
best_ntree <- 0

# Loop over ntree values
for (ntree in c(50, 100, 150)) {
  # Perform hyperparameter tuning using the train function
  fpl_2021_22_tuned <- train(total_points ~ .,
                             data = twenty21_train,
                             method = "rf",
                             trControl = ctrl,
                             tuneGrid = tuning_grid,
                             ntree = ntree)
  
  # Obtain the optimal mtry value
  optimal_mtry <- fpl_2021_22_tuned$bestTune$mtry
  
  # Train the random forest model with the optimal mtry and ntree values
  final_model <- randomForest::randomForest(total_points ~ .,
                                            data = twenty21_train,
                                            mtry = optimal_mtry,
                                            ntree = ntree)
  
  # Make predictions on the test set
  fpl_2021_22_prediction_test <- predict(final_model, twenty21_test)
  
  # Calculate mean absolute error (MAE)
  mae_values[i] <- mean(abs(twenty21_test$total_points - predictions))
  
  # Check if this model has the best performance so far
  if (mae < best_mae) {
    best_mae <- mae
    best_ntree <- ntree
  }
}


# Shows that n_tree = 150 is best 

```

## Best model after hyper parameter tuning

```{r}
set.seed(123)

ctrl <- trainControl(method="repeatedcv", 
                     number=5, 
                     repeats = 3)


fpl_2021_22_forest_tuned<- train(total_points~., twenty21_train, method="rf", trControl= ctrl, ntree = 150)


fpl_2021_22_prediction_test_tuned <- predict(fpl_2021_22_forest_tuned, twenty21_test)
fpl_2021_22_prediction_train_tuned <- predict(fpl_2021_22_forest_tuned, twenty21_train)

```

## Evaluating the performance of the tuned model

```{r}
yardstick::mae_vec(truth = twenty21_train$total_points, estimate = fpl_2021_22_prediction_train_tuned)

yardstick::mae_vec(truth =  twenty21_test$total_points, estimate = fpl_2021_22_prediction_test_tuned)
```

# Time for predictions

## Preparing the 2022/23 data set to be ready for prediction 
(Here i must explain what I am doing in the code below)

```{r}
# Preparing my 2022/23 data set so it is ready for predictions 
#Creating  a new data set that only contains variables that can be seen before the game starts

predicter_variables_2022_23 <- c("creativity", "ict_index", "influence", "selected", "threat", "transfers_in", "total_points", "team")

# Subset the data frame to keep only the selected variables
twenty22_test <- merged_gameweek_2022_23[, predicter_variables_2022_23]

# Create a vector of the team names to be removed
teams_to_remove <- c("Bournemouth", "Nott'm Forest", "Fulham")

# Remove the rows with the teams to be removed from twenty22_test
twenty22_test <- twenty22_test[!twenty22_test$team %in% teams_to_remove, ]

#remove these teams from the original dataset as well
merged_gameweek_2022_23 <- merged_gameweek_2022_23[!merged_gameweek_2022_23$team %in% teams_to_remove, ]

# Step 3: Make predictions using the trained random forest model
predictions <- predict(fpl_2021_22_forest_tuned, newdata = twenty22_test)

# make a vector with the names: 
names_22_23 <- merged_gameweek_2022_23$name

#add names back to the twenty22_test dataset 
twenty22_test$names_22_23 <- names_22_23

# Add the predictions to the twenty22_test dataset
twenty22_test$predicted_points <- predictions

# Make a vector with game week 
gameweek <- merged_gameweek_2022_23$GW

# Add the gameweek back into the data set
twenty22_test$gameweek <- gameweek

# make a vector with the position 
position <- merged_gameweek_2022_23$position

# add the position back into the data set
twenty22_test$position <- position

# make a vector with value 
value <- merged_gameweek_2022_23$value

# add the value vector back into the data set
twenty22_test$value <- value
```

## Game week predictions 







# Conclusion

<!-- Make title of bibliography here: -->
<!-- \newpage -->

\newpage

# References {-}

<div id="refs"></div>


# Appendix {-}

## Appendix A {-}

Some appendix information here

## Appendix B {-}

